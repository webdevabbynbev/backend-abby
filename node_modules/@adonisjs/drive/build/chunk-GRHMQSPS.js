import {
  __export
} from "./chunk-MLKGABMK.js";

// src/errors.ts
var errors_exports = {};
__export(errors_exports, {
  CannotServeFileException: () => CannotServeFileException
});
import { Exception } from "@adonisjs/core/exceptions";
var CannotServeFileException = class extends Exception {
  debug = process.env.NODE_ENV !== "production";
  constructor(originalError) {
    super("Cannot serve local file using drive", {
      code: "E_CANNOT_SERVE_FILE",
      status: 500,
      cause: originalError
    });
  }
  /**
   * Returns the root cause of the error by reading
   * the nested "error.cause" property in recursive
   * manner.
   */
  #getRootCause(error) {
    if (error && typeof error === "object" && "cause" in error) {
      return this.#getRootCause(error.cause);
    }
    return error;
  }
  /**
   * Parses the original error to find the accurate error
   * message, stack and the status code.
   */
  parseError(error) {
    const rootCause = this.#getRootCause(error);
    const message = rootCause.message || error.message;
    const stack = rootCause.stack;
    const code = rootCause.code;
    const status = code === "ENOENT" || message.includes("Cannot get metadata of a directory") ? 404 : 500;
    return { stack, status, message };
  }
  /**
   * Converts error to an HTTP response.
   */
  handle(error, ctx) {
    if (!this.debug) {
      return ctx.response.status(404).send("File not found");
    }
    let { stack, status, message } = this.parseError(error);
    return ctx.response.status(status).send(`${message}${stack ? `
Stack:${stack}` : ""}`);
  }
  /**
   * Reporting the error using the logger
   */
  report(error, ctx) {
    const { stack, status, message } = this.parseError(error);
    if (status === 404) {
      ctx.logger.warn(message);
    } else {
      ctx.logger.error({ err: stack }, message);
    }
  }
};

// src/debug.ts
import { debuglog } from "node:util";
var debug_default = debuglog("adonisjs:drive");

export {
  CannotServeFileException,
  errors_exports,
  debug_default
};
